diff --git a/js/build_jsep.bat b/js/build_jsep.bat
index 33a842d36c..e125cbcb07 100644
--- a/js/build_jsep.bat
+++ b/js/build_jsep.bat
@@ -64,8 +64,7 @@ popd
 
 set PATH=C:\Program Files\Git\usr\bin;%PATH%
 
-call %ROOT%build.bat --config %CONFIG% %CONFIG_EXTRA_FLAG% --skip_submodule_sync --build_wasm --skip_tests^
---enable_wasm_simd --enable_wasm_threads --use_jsep --use_webnn --target onnxruntime_webassembly --build_dir %BUILD_DIR%
+call %ROOT%build.bat --config %CONFIG% %CONFIG_EXTRA_FLAG% --skip_submodule_sync --build_wasm --skip_tests --enable_wasm_simd --enable_wasm_threads --use_jsep --use_webnn --target onnxruntime_webassembly --build_dir %BUILD_DIR%
 
 IF NOT "%ERRORLEVEL%" == "0" (
   exit /b %ERRORLEVEL%
diff --git a/js/web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts b/js/web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
index 6117384659..11cedc78f6 100644
--- a/js/web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
+++ b/js/web/lib/wasm/jsep/webgpu/ops/3rd-party/conv3d_naive_webgpu.ts
@@ -177,13 +177,17 @@ export const computeConv3DInfo =
       if (dataFormat === 'channelsLast') {
         [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;
 
-        [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
+        // [filterDepth, filterHeight, filterWidth, , filterChannels] = filterShape;
+        // Workaround for brainchop
+        //[filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
       } else if (dataFormat === 'channelsFirst') {
         [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;
-        [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
+        //[filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
       } else {
         throw new Error(`Unknown dataFormat ${dataFormat}`);
       }
+      // Filter is NCDHW
+      [filterChannels, , filterDepth, filterHeight, filterWidth] = filterShape;
 
       const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);
       const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);
@@ -238,10 +242,11 @@ export const createConv3DNaiveProgramInfo =
     (inputs: readonly TensorView[], attributes: ConvAttributes, outputShape: readonly number[],
      filterDims: readonly number[], pads: readonly number[], dataFormat: string): ProgramInfo => {
       const isChannelsLast = dataFormat === 'channelsLast';  // ;// attributes.format === 'NHWC';
+      // const isWChannelsLast = false;
       const inChannels = isChannelsLast ? inputs[0].dims[3] : inputs[0].dims[1];
-      const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
+      //const outChannels = isChannelsLast ? outputShape[3] : outputShape[1];
       // TODO: enable vec4 for NCHW
-      const isVec4 = isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
+      const isVec4 = false;// isChannelsLast && (inChannels % 4 === 0 || inChannels % 3 === 0) && outChannels % 4 === 0;
       const workGroupSize: [number, number, number] = [64, 1, 1];
       const dispatchLayout = {x: outputShape.map((_, i) => i)};
       const dispatch = [Math.ceil(arrayProduct(dispatchLayout.x.map(d => outputShape[d])) / (workGroupSize[0])), 1, 1];
@@ -370,29 +375,34 @@ export const createConv3DNaiveProgramInfo =
                                getX(batch, xF, xR, xC, d1 + 1),
                                getX(batch, xF, xR, xC, d1 + 2),
                                getX(batch, xF, xR, xC, d1 + 3));
-                             let wValues = vec4<f32>(
-                               getW(wF, wR, wC, d1, d2),
-                               getW(wF, wR, wC, d1 + 1, d2),
-                               getW(wF, wR, wC, d1 + 2, d2),
-                               getW(wF, wR, wC, d1 + 3, d2));
+                             //let wValues = vec4<f32>(
+                             //  getW(wF, wR, wC, d1, d2),
+                             //  getW(wF, wR, wC, d1 + 1, d2),
+                             //  getW(wF, wR, wC, d1 + 2, d2),
+                             //  getW(wF, wR, wC, d1 + 3, d2));
                             ` :
                              `let xValues = vec4<f32>(
                                getX(batch, d1, xF, xR, xC),
                                getX(batch, d1 + 1, xF, xR, xC),
                                getX(batch, d1 + 2, xF, xR, xC),
                                getX(batch, d1 + 3, xF, xR, xC));
-                             let wValues = vec4<f32>(
-                               getW(d2, d1, wF, wR, wC),
-                               getW(d2, d1 + 1, wF, wR, wC),
-                               getW(d2, d1 + 2, wF, wR, wC),
-                               getW(d2, d1 + 3, wF, wR, wC));
+                             //let wValues = vec4<f32>(
+                             //  getW(d2, d1, wF, wR, wC),
+                             //  getW(d2, d1 + 1, wF, wR, wC),
+                             //  getW(d2, d1 + 2, wF, wR, wC),
+                             //  getW(d2, d1 + 3, wF, wR, wC));
                             `}
+                            let wValues = vec4<f32>(
+                              getW(d2, d1, wF, wR, wC),
+                              getW(d2, d1 + 1, wF, wR, wC),
+                              getW(d2, d1 + 2, wF, wR, wC),
+                              getW(d2, d1 + 3, wF, wR, wC));
                       dotProd += dot(xValues, wValues);
                     }
                     if (inputDepthVec4Remainder == 1) {
                         ${
             isChannelsLast ? `dotProd += getX(batch, xF, xR, xC, inputDepthNearestVec4)
-                          * getW(wF, wR, wC, inputDepthNearestVec4, d2);` :
+                          * getW(d2, inputDepthNearestVec4, wF, wR, wC);` :
                              `dotProd += getX(batch, inputDepthNearestVec4, xF, xR, xC)
                           * getW(d2, inputDepthNearestVec4, wF, wR, wC);`}
                     } else if (inputDepthVec4Remainder == 2) {
@@ -400,17 +410,20 @@ export const createConv3DNaiveProgramInfo =
             isChannelsLast ? `let xValues = vec2<f32>(
                         getX(batch, xF, xR, xC, inputDepthNearestVec4),
                         getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1));
-                      let wValues = vec2<f32>(
-                        getW(wF, wR, wC, inputDepthNearestVec4, d2),
-                        getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2));
+                      //let wValues = vec2<f32>(
+                      //  getW(wF, wR, wC, inputDepthNearestVec4, d2),
+                      //  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2));
                       ` :
                              `let xValues = vec2<f32>(
                         getX(batch, inputDepthNearestVec4, xF, xR, xC),
                         getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC));
-                      let wValues = vec2<f32>(
-                        getW(d2, inputDepthNearestVec4, wF, wR, wC),
-                        getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
+                      //let wValues = vec2<f32>(
+                      //  getW(d2, inputDepthNearestVec4, wF, wR, wC),
+                      //  getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                     `}
+                    let wValues = vec2<f32>(
+                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
+                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC));
                       dotProd += dot(xValues, wValues);
                     } else if (inputDepthVec4Remainder == 3) {
                       ${
@@ -418,20 +431,24 @@ export const createConv3DNaiveProgramInfo =
                         getX(batch, xF, xR, xC, inputDepthNearestVec4),
                         getX(batch, xF, xR, xC, inputDepthNearestVec4 + 1),
                         getX(batch, xF, xR, xC, inputDepthNearestVec4 + 2));
-                      let wValues = vec3<f32>(
-                        getW(wF, wR, wC, inputDepthNearestVec4, d2),
-                        getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
-                        getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2));
+                      //let wValues = vec3<f32>(
+                      //  getW(wF, wR, wC, inputDepthNearestVec4, d2),
+                      //  getW(wF, wR, wC, inputDepthNearestVec4 + 1, d2),
+                      //  getW(wF, wR, wC, inputDepthNearestVec4 + 2, d2));
                       ` :
                              `let xValues = vec3<f32>(
                         getX(batch, inputDepthNearestVec4, xF, xR, xC),
                         getX(batch, inputDepthNearestVec4 + 1, xF, xR, xC),
                         getX(batch, inputDepthNearestVec4 + 2, xF, xR, xC));
-                      let wValues = vec3<f32>(
-                        getW(d2, inputDepthNearestVec4, wF, wR, wC),
-                        getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
-                        getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
+                      //let wValues = vec3<f32>(
+                      //  getW(d2, inputDepthNearestVec4, wF, wR, wC),
+                      //  getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
+                      //  getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                     `}
+                    let wValues = vec3<f32>(
+                      getW(d2, inputDepthNearestVec4, wF, wR, wC),
+                      getW(d2, inputDepthNearestVec4 + 1, wF, wR, wC),
+                      getW(d2, inputDepthNearestVec4 + 2, wF, wR, wC));
                       dotProd += dot(xValues, wValues);
                     }
                   }
diff --git a/js/web/lib/wasm/jsep/webgpu/ops/conv.ts b/js/web/lib/wasm/jsep/webgpu/ops/conv.ts
index a4207f376b..e7aefc0f7a 100644
--- a/js/web/lib/wasm/jsep/webgpu/ops/conv.ts
+++ b/js/web/lib/wasm/jsep/webgpu/ops/conv.ts
@@ -119,7 +119,7 @@ const getAdjustedConvAttributes = <T extends ConvAttributes>(attributes: T, inpu
 export const parseConvAttributes = (attributes: Record<string, unknown>): ConvAttributes => {
   const activationAttributes = parseInternalActivationAttributes(attributes);
   // TODO : Make this generic enough to compute default attributes for multi-dimensional conv
-  const format = attributes.format as 'NHWC' | 'NCHW';
+  const format = 'NHWC'; // attributes.format as 'NHWC' | 'NCHW';
   const autoPad = ['NOTSET', 'VALID', 'SAME_UPPER', 'SAME_LOWER'][attributes.auto_pad as number];
   const dilations = attributes.dilations as number[];
   const group = attributes.group as number;
diff --git a/onnxruntime/core/providers/js/operators/conv.h b/onnxruntime/core/providers/js/operators/conv.h
index 32e8e1faca..551c562155 100644
--- a/onnxruntime/core/providers/js/operators/conv.h
+++ b/onnxruntime/core/providers/js/operators/conv.h
@@ -47,6 +47,7 @@ class ConvBase : public JsKernel {
     conv_attrs_.activation = info.GetAttrOrDefault<std::string>("activation", "");
     std::vector<float> activation_params = info.GetAttrsOrDefault<float>("activation_params");
     int64_t channels_last = is_channels_last ? 1 : info.GetAttrOrDefault<int64_t>("channels_last", 0);
+    printf("%s::%d,%ld", __FUNCTION__, __LINE__,(long)channels_last);
 
     // currently only support Conv 1D/2D. TODO: support Conv3D and other
     JSEP_INIT_KERNEL_ATTRIBUTE(Conv, ({
